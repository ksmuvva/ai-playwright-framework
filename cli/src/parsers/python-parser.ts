/**
 * Python Script Parser for Playwright Recordings
 *
 * This module parses Playwright Python scripts generated by `playwright codegen`
 * and extracts actions into a normalized intermediate format.
 *
 * ROOT CAUSE FIX (RC1, RC2):
 * - Addresses format mismatch (expects JSON, receives Python)
 * - Implements comprehensive Python parsing for modern Playwright API
 *
 * Supports:
 * - page.goto()
 * - page.get_by_role(), page.get_by_text(), page.get_by_label(), etc.
 * - .click(), .fill(), .press(), .check(), .select_option()
 * - expect() assertions
 * - expect_popup() context managers
 * - Multiple page objects
 */

import { Logger } from '../utils/logger';

export interface ParsedPlaywrightAction {
  type: 'goto' | 'click' | 'fill' | 'press' | 'check' | 'select' | 'expect' | 'popup' | 'close' | 'hover' | 'dblclick';

  // Locator information
  locatorType?: 'role' | 'text' | 'label' | 'placeholder' | 'testid' | 'locator' | 'css' | 'xpath';
  locatorValue?: string;  // The role/text/label value (e.g., "button", "Submit")
  elementName?: string;   // The accessible name (e.g., name="Submit" → "Submit")

  // Action-specific data
  value?: string;         // For fill, select, press actions
  url?: string;           // For goto actions

  // Assertion information
  assertion?: {
    type: 'url' | 'title' | 'visible' | 'text' | 'count' | 'value';
    expected: string;
    matcher?: string;  // e.g., 'contains', 'equals', 'matches'
  };

  // Context
  rawLine: string;        // Original Python code for debugging
  lineNumber: number;     // Line number in source file
  pageContext?: string;   // 'page', 'page1', 'page2' for multi-page scenarios
}

export interface ParsedRecording {
  actions: ParsedPlaywrightAction[];
  metadata: {
    startUrl?: string;
    browser?: string;
    headless?: boolean;
    hasPopups: boolean;
    hasAssertions: boolean;
    hasMultiplePages: boolean;
    totalActions: number;
  };
  parseErrors: Array<{
    line: string;
    lineNumber: number;
    reason: string;
  }>;
}

/**
 * Main entry point: Parse a Playwright Python script
 */
export function parsePythonScript(content: string): ParsedRecording {
  Logger.info('Parsing Python script with modern Playwright API...');

  const lines = content.split('\n');
  const actions: ParsedPlaywrightAction[] = [];
  const parseErrors: Array<{ line: string; lineNumber: number; reason: string }> = [];

  const metadata = {
    startUrl: undefined as string | undefined,
    browser: 'chromium',
    headless: false,
    hasPopups: false,
    hasAssertions: false,
    hasMultiplePages: false,
    totalActions: 0
  };

  // Regex patterns for Playwright Python API
  const patterns = createPatterns();

  // Track current page context (for multi-page scenarios)
  let currentPageContext = 'page';
  let inPopupContext = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    const lineNumber = i + 1;

    // Skip boilerplate and comments
    if (shouldSkipLine(trimmed)) {
      continue;
    }

    // Extract metadata
    extractMetadata(trimmed, patterns, metadata);

    // Handle popup context
    if (patterns.expectPopup.test(trimmed)) {
      inPopupContext = true;
      metadata.hasPopups = true;
      actions.push({
        type: 'popup',
        rawLine: trimmed,
        lineNumber,
        pageContext: currentPageContext
      });

      // Next page will be page1, page2, etc.
      const popupMatch = trimmed.match(/(\w+)_info/);
      if (popupMatch) {
        currentPageContext = popupMatch[1];
        metadata.hasMultiplePages = true;
      }
      continue;
    }

    // Handle page variable assignments (page1 = page1_info.value)
    const pageAssignMatch = trimmed.match(/^(page\d+)\s*=\s*\w+_info\.value/);
    if (pageAssignMatch) {
      currentPageContext = pageAssignMatch[1];
      continue;
    }

    // Handle page close
    if (patterns.pageClose.test(trimmed)) {
      const closeMatch = trimmed.match(/(page\d*)\.close/);
      const closedPage = closeMatch ? closeMatch[1] : currentPageContext;

      actions.push({
        type: 'close',
        rawLine: trimmed,
        lineNumber,
        pageContext: closedPage
      });

      // Reset to main page if popup closed
      if (closedPage !== 'page') {
        currentPageContext = 'page';
        inPopupContext = false;
      }
      continue;
    }

    // Parse goto (navigation)
    const gotoAction = parseGoto(trimmed, patterns, lineNumber, currentPageContext);
    if (gotoAction) {
      if (!metadata.startUrl) {
        metadata.startUrl = gotoAction.url;
      }
      actions.push(gotoAction);
      continue;
    }

    // Parse assertions (expect)
    if (trimmed.startsWith('expect(')) {
      metadata.hasAssertions = true;
      const assertAction = parseAssertion(trimmed, patterns, lineNumber, currentPageContext);
      if (assertAction) {
        actions.push(assertAction);
      } else {
        parseErrors.push({
          line: trimmed,
          lineNumber,
          reason: 'Could not parse expect() assertion'
        });
      }
      continue;
    }

    // Parse element interactions (click, fill, etc.)
    if (containsPlaywrightAction(trimmed)) {
      const action = parseElementInteraction(trimmed, patterns, lineNumber, currentPageContext);
      if (action) {
        actions.push(action);
      } else {
        parseErrors.push({
          line: trimmed,
          lineNumber,
          reason: 'Could not parse Playwright action'
        });
      }
      continue;
    }
  }

  metadata.totalActions = actions.length;

  Logger.info(`✓ Parsed ${actions.length} actions (${parseErrors.length} errors)`);
  if (metadata.hasPopups) Logger.info('  - Contains popup/new window interactions');
  if (metadata.hasAssertions) Logger.info('  - Contains assertions');
  if (metadata.hasMultiplePages) Logger.info('  - Multiple page contexts detected');

  if (parseErrors.length > 0) {
    Logger.warning(`⚠️  ${parseErrors.length} lines could not be parsed:`);
    parseErrors.slice(0, 3).forEach(err => {
      Logger.warning(`  Line ${err.lineNumber}: ${err.reason}`);
    });
  }

  return { actions, metadata, parseErrors };
}

/**
 * Create regex patterns for parsing
 */
function createPatterns() {
  return {
    // Navigation
    goto: /\.goto\(["'](.+?)["']\)/,

    // Element locators (Modern Playwright API)
    getByRole: /\.get_by_role\(["'](\w+)["'](?:,\s*name=["'](.+?)["'])?\)/,
    getByText: /\.get_by_text\(["'](.+?)["'](?:,\s*exact=(True|False))?\)/,
    getByLabel: /\.get_by_label\(["'](.+?)["']\)/,
    getByPlaceholder: /\.get_by_placeholder\(["'](.+?)["']\)/,
    getByTestId: /\.get_by_test_id\(["'](.+?)["']\)/,
    getByTitle: /\.get_by_title\(["'](.+?)["']\)/,
    getByAltText: /\.get_by_alt_text\(["'](.+?)["']\)/,

    // Legacy locators
    locator: /\.locator\(["'](.+?)["']\)/,
    clickSelector: /\.click\(["'](.+?)["']\)/,
    fillSelector: /\.fill\(["'](.+?)["'],\s*["'](.+?)["']\)/,

    // Actions
    click: /\.click\(\)/,
    dblclick: /\.dblclick\(\)/,
    hover: /\.hover\(\)/,
    fill: /\.fill\(["'](.*)["']\)/,
    press: /\.press\(["'](.+?)["']\)/,
    check: /\.check\(\)/,
    uncheck: /\.uncheck\(\)/,
    selectOption: /\.select_option\(["'](.+?)["']\)/,

    // Assertions
    expectUrl: /expect\((\w+)\)\.to_have_url\((.+?)\)/,
    expectTitle: /expect\((\w+)\)\.to_have_title\((.+?)\)/,
    expectVisible: /expect\((.+?)\)\.to_be_visible\(\)/,
    expectHidden: /expect\((.+?)\)\.to_be_hidden\(\)/,
    expectEnabled: /expect\((.+?)\)\.to_be_enabled\(\)/,
    expectDisabled: /expect\((.+?)\)\.to_be_disabled\(\)/,
    expectText: /expect\((.+?)\)\.to_have_text\(["'](.+?)["']\)/,
    expectValue: /expect\((.+?)\)\.to_have_value\(["'](.+?)["']\)/,
    expectCount: /expect\((.+?)\)\.to_have_count\((\d+)\)/,

    // Special patterns
    expectPopup: /with\s+(\w+)\.expect_popup\(\)/,
    pageClose: /(page\d*)\.close\(\)/,

    // Browser setup (metadata)
    browserLaunch: /playwright\.(\w+)\.launch\(/,
    headlessMode: /headless=(True|False)/,
  };
}

/**
 * Check if line should be skipped (boilerplate)
 */
function shouldSkipLine(line: string): boolean {
  if (!line || line.startsWith('#')) return true;

  const boilerplate = [
    /^import\s/,
    /^from\s/,
    /^def\s+run/,
    /^def\s+\w+\(playwright/,
    /^browser\s*=/,
    /^context\s*=/,
    /^page\s*=\s*context\.new_page/,
    /^context\.close/,
    /^browser\.close/,
    /^with\s+sync_playwright/,
    /^\s*run\(playwright\)/,
    /^\s*playwright\.run\(/,
    /^# -+/,  // Comment separators
    /^"""/,    // Docstrings
    /^'''/,    // Docstrings
    /page\d+\s*=\s*\w+_info\.value/  // Popup variable assignment (handled separately)
  ];

  return boilerplate.some(pattern => pattern.test(line));
}

/**
 * Extract metadata from line
 */
function extractMetadata(line: string, patterns: any, metadata: any): void {
  // Extract browser type
  const browserMatch = line.match(patterns.browserLaunch);
  if (browserMatch) {
    metadata.browser = browserMatch[1];
  }

  // Extract headless mode
  const headlessMatch = line.match(patterns.headlessMode);
  if (headlessMatch) {
    metadata.headless = headlessMatch[1] === 'True';
  }
}

/**
 * Parse page.goto() navigation
 */
function parseGoto(
  line: string,
  patterns: any,
  lineNumber: number,
  pageContext: string
): ParsedPlaywrightAction | null {
  const match = line.match(patterns.goto);
  if (!match) return null;

  return {
    type: 'goto',
    url: match[1],
    rawLine: line,
    lineNumber,
    pageContext
  };
}

/**
 * Parse expect() assertions
 */
function parseAssertion(
  line: string,
  patterns: any,
  lineNumber: number,
  pageContext: string
): ParsedPlaywrightAction | null {

  // to_have_url
  const urlMatch = line.match(patterns.expectUrl);
  if (urlMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'url',
        expected: urlMatch[2].replace(/["']/g, ''),
        matcher: 'equals'
      },
      rawLine: line,
      lineNumber,
      pageContext: urlMatch[1]
    };
  }

  // to_have_title
  const titleMatch = line.match(patterns.expectTitle);
  if (titleMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'title',
        expected: titleMatch[2].replace(/["']/g, ''),
        matcher: 'equals'
      },
      rawLine: line,
      lineNumber,
      pageContext: titleMatch[1]
    };
  }

  // to_be_visible
  const visibleMatch = line.match(patterns.expectVisible);
  if (visibleMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'visible',
        expected: 'true'
      },
      locatorValue: visibleMatch[1],
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // to_be_hidden
  const hiddenMatch = line.match(patterns.expectHidden);
  if (hiddenMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'visible',
        expected: 'false'
      },
      locatorValue: hiddenMatch[1],
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // to_have_text
  const textMatch = line.match(patterns.expectText);
  if (textMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'text',
        expected: textMatch[2]
      },
      locatorValue: textMatch[1],
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // to_have_value
  const valueMatch = line.match(patterns.expectValue);
  if (valueMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'value',
        expected: valueMatch[2]
      },
      locatorValue: valueMatch[1],
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // to_have_count
  const countMatch = line.match(patterns.expectCount);
  if (countMatch) {
    return {
      type: 'expect',
      assertion: {
        type: 'count',
        expected: countMatch[2]
      },
      locatorValue: countMatch[1],
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  return null;
}

/**
 * Check if line contains a Playwright action
 */
function containsPlaywrightAction(line: string): boolean {
  return (
    line.includes('.get_by_') ||
    line.includes('.locator(') ||
    line.includes('.click(') ||
    line.includes('.fill(') ||
    line.includes('.press(') ||
    line.includes('.hover(') ||
    line.includes('.check(') ||
    line.includes('.select_option(')
  );
}

/**
 * Parse element interaction (click, fill, etc.)
 */
function parseElementInteraction(
  line: string,
  patterns: any,
  lineNumber: number,
  pageContext: string
): ParsedPlaywrightAction | null {

  // First, extract the locator
  let locatorType: ParsedPlaywrightAction['locatorType'];
  let locatorValue: string | undefined;
  let elementName: string | undefined;

  // Try get_by_role
  const roleMatch = line.match(patterns.getByRole);
  if (roleMatch) {
    locatorType = 'role';
    locatorValue = roleMatch[1];  // e.g., 'textbox', 'button'
    elementName = roleMatch[2];   // e.g., 'Username', 'Submit'
  }

  // Try get_by_text
  if (!locatorType) {
    const textMatch = line.match(patterns.getByText);
    if (textMatch) {
      locatorType = 'text';
      locatorValue = textMatch[1];
    }
  }

  // Try get_by_label
  if (!locatorType) {
    const labelMatch = line.match(patterns.getByLabel);
    if (labelMatch) {
      locatorType = 'label';
      locatorValue = labelMatch[1];
    }
  }

  // Try get_by_placeholder
  if (!locatorType) {
    const placeholderMatch = line.match(patterns.getByPlaceholder);
    if (placeholderMatch) {
      locatorType = 'placeholder';
      locatorValue = placeholderMatch[1];
    }
  }

  // Try get_by_test_id
  if (!locatorType) {
    const testIdMatch = line.match(patterns.getByTestId);
    if (testIdMatch) {
      locatorType = 'testid';
      locatorValue = testIdMatch[1];
    }
  }

  // Try get_by_title
  if (!locatorType) {
    const titleMatch = line.match(patterns.getByTitle);
    if (titleMatch) {
      locatorType = 'text';  // Treat title as text for BDD
      locatorValue = titleMatch[1];
    }
  }

  // Try locator (CSS/XPath)
  if (!locatorType) {
    const locatorMatch = line.match(patterns.locator);
    if (locatorMatch) {
      const selector = locatorMatch[1];
      // Determine if CSS or XPath
      locatorType = selector.startsWith('//') || selector.startsWith('(//') ? 'xpath' : 'css';
      locatorValue = selector;
    }
  }

  // If no locator found, try legacy click/fill with selector
  if (!locatorType) {
    const clickMatch = line.match(patterns.clickSelector);
    if (clickMatch) {
      locatorType = 'css';
      locatorValue = clickMatch[1];

      return {
        type: 'click',
        locatorType,
        locatorValue,
        rawLine: line,
        lineNumber,
        pageContext
      };
    }

    const fillMatch = line.match(patterns.fillSelector);
    if (fillMatch) {
      locatorType = 'css';
      locatorValue = fillMatch[1];

      return {
        type: 'fill',
        locatorType,
        locatorValue,
        value: fillMatch[2],
        rawLine: line,
        lineNumber,
        pageContext
      };
    }
  }

  // No locator found
  if (!locatorType) {
    return null;
  }

  // Now determine the action type

  // Fill
  if (patterns.fill.test(line)) {
    const fillMatch = line.match(patterns.fill);
    return {
      type: 'fill',
      locatorType,
      locatorValue,
      elementName,
      value: fillMatch ? fillMatch[1] : '',
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Click
  if (patterns.click.test(line)) {
    return {
      type: 'click',
      locatorType,
      locatorValue,
      elementName,
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Double click
  if (patterns.dblclick.test(line)) {
    return {
      type: 'dblclick',
      locatorType,
      locatorValue,
      elementName,
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Hover
  if (patterns.hover.test(line)) {
    return {
      type: 'hover',
      locatorType,
      locatorValue,
      elementName,
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Press key
  if (patterns.press.test(line)) {
    const pressMatch = line.match(patterns.press);
    return {
      type: 'press',
      locatorType,
      locatorValue,
      elementName,
      value: pressMatch ? pressMatch[1] : '',
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Check
  if (patterns.check.test(line)) {
    return {
      type: 'check',
      locatorType,
      locatorValue,
      elementName,
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // Select option
  if (patterns.selectOption.test(line)) {
    const selectMatch = line.match(patterns.selectOption);
    return {
      type: 'select',
      locatorType,
      locatorValue,
      elementName,
      value: selectMatch ? selectMatch[1] : '',
      rawLine: line,
      lineNumber,
      pageContext
    };
  }

  // If we have a locator but no action, it might be a locator chain we don't support yet
  return null;
}

/**
 * Convert parsed actions back to legacy PlaywrightAction format for compatibility
 */
export function convertToLegacyFormat(parsed: ParsedRecording): Array<{
  type: string;
  selector?: string;
  value?: string;
  url?: string;
}> {
  return parsed.actions.map(action => {
    // Build human-readable selector
    let selector = '';
    if (action.locatorType && action.locatorValue) {
      if (action.elementName) {
        selector = `${action.locatorType}[name="${action.elementName}"]`;
      } else {
        selector = `${action.locatorType}["${action.locatorValue}"]`;
      }
    }

    return {
      type: action.type,
      selector,
      value: action.value,
      url: action.url
    };
  });
}
